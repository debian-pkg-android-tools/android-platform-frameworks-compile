Description:
  LLVM 3.5 has dropped OwningPtr<T> and we are replacing it with
  std::unique_ptr<T>.
Author: Kai-Chung Yan <seamlikok@gmail.com>
Last-Update: 2015-08-12
--- a/linkloader/include/ELFObject.h
+++ b/linkloader/include/ELFObject.h
@@ -22,10 +22,10 @@
 
 #include "utils/rsl_assert.h"
 
-#include <llvm/ADT/OwningPtr.h>
-
 #include <string>
 #include <vector>
+#include <memory>
+
 
 template <unsigned Bitwidth>
 class ELFObject {
@@ -33,8 +33,8 @@
   ELF_TYPE_INTRO_TO_TEMPLATE_SCOPE(Bitwidth);
 
 private:
-  llvm::OwningPtr<ELFHeaderTy> header;
-  llvm::OwningPtr<ELFSectionHeaderTableTy> shtab;
+  std::unique_ptr<ELFHeaderTy> header;
+  std::unique_ptr<ELFSectionHeaderTableTy> shtab;
   std::vector<ELFSectionTy *> stab;
 
   MemChunk SHNCommonData;
--- a/linkloader/include/ELFHeader.h
+++ b/linkloader/include/ELFHeader.h
@@ -20,9 +20,8 @@
 #include "ELFTypes.h"
 #include "ELF.h"
 
-#include <llvm/ADT/OwningPtr.h>
-
 #include <string.h>
+#include <memory>
 
 class ELFHeaderHelperMixin {
 protected:
@@ -155,7 +154,7 @@
       return 0;
     }
 
-    llvm::OwningPtr<ELFHeader> header(new ELFHeader());
+    std::unique_ptr<ELFHeader> header(new ELFHeader());
     if (!header->serialize(AR)) {
       // Unable to read the structure.  Return NULL.
       return 0;
@@ -166,7 +165,7 @@
       return 0;
     }
 
-    return header.take();
+    return header.release();
   }
 
   void print();
--- a/linkloader/include/ELFSymbol.h
+++ b/linkloader/include/ELFSymbol.h
@@ -20,8 +20,6 @@
 #include "ELFTypes.h"
 #include "ELF.h"
 
-#include <llvm/ADT/OwningPtr.h>
-
 #include <string>
 #include <algorithm>
 
--- a/linkloader/include/ELFReloc.h
+++ b/linkloader/include/ELFReloc.h
@@ -20,7 +20,6 @@
 #include "ELFTypes.h"
 #include "utils/rsl_assert.h"
 
-#include <llvm/ADT/OwningPtr.h>
 #include <string>
 #include <stdint.h>
 
--- a/linkloader/include/ELFSection.h
+++ b/linkloader/include/ELFSection.h
@@ -18,7 +18,6 @@
 #define ELF_SECTION_H
 
 #include "ELFTypes.h"
-#include <llvm/ADT/OwningPtr.h>
 
 template <unsigned Bitwidth>
 class ELFSection {
--- a/linkloader/include/ELFSectionHeaderTable.h
+++ b/linkloader/include/ELFSectionHeaderTable.h
@@ -19,7 +19,6 @@
 
 #include "ELFTypes.h"
 
-#include <llvm/ADT/OwningPtr.h>
 #include <llvm/ADT/StringMap.h>
 
 #include <vector>
--- a/linkloader/include/ELFSectionHeader.h
+++ b/linkloader/include/ELFSectionHeader.h
@@ -19,7 +19,6 @@
 
 #include "ELFTypes.h"
 
-#include <llvm/ADT/OwningPtr.h>
 #include <stdint.h>
 
 class ELFSectionHeaderHelperMixin {
--- a/linkloader/include/ELFSectionBits.h
+++ b/linkloader/include/ELFSectionBits.h
@@ -21,8 +21,6 @@
 #include "ELFSection.h"
 #include "MemChunk.h"
 
-#include <llvm/ADT/OwningPtr.h>
-
 template <unsigned Bitwidth>
 class ELFSectionBits : public ELFSection<Bitwidth> {
 protected:
--- a/linkloader/include/impl/ELFSectionStrTab.hxx
+++ b/linkloader/include/impl/ELFSectionStrTab.hxx
@@ -20,7 +20,7 @@
 #include "utils/helper.h"
 #include "utils/raw_ostream.h"
 
-#include <llvm/ADT/OwningPtr.h>
+#include <memory>
 #include <llvm/Support/Format.h>
 #include <llvm/Support/raw_ostream.h>
 
@@ -30,7 +30,7 @@
 ELFSectionStrTab<Bitwidth>::read(Archiver &AR,
                                  ELFSectionHeaderTy const *sh) {
 
-  llvm::OwningPtr<ELFSectionStrTab> st(new ELFSectionStrTab());
+  std::unique_ptr<ELFSectionStrTab> st(new ELFSectionStrTab());
   st->buf.resize(sh->getSize());
 
   // Save section_header
@@ -46,7 +46,7 @@
     return 0;
   }
 
-  return st.take();
+  return st.release();
 }
 
 template <unsigned Bitwidth>
--- a/linkloader/include/impl/ELFSectionNoBits.hxx
+++ b/linkloader/include/impl/ELFSectionNoBits.hxx
@@ -25,12 +25,13 @@
 #include <llvm/Support/raw_ostream.h>
 
 #include <sys/mman.h>
+#include <memory>
 
 template <unsigned Bitwidth>
 template <typename Archiver>
 inline ELFSectionNoBits<Bitwidth> *
 ELFSectionNoBits<Bitwidth>::read(Archiver &AR, ELFSectionHeaderTy const *sh) {
-  llvm::OwningPtr<ELFSectionNoBits> result(new ELFSectionNoBits());
+  std::unique_ptr<ELFSectionNoBits> result(new ELFSectionNoBits());
 
   if (!result->chunk.allocate(sh->getSize())) {
     return NULL;
@@ -38,7 +39,7 @@
 
   result->sh = sh;
 
-  return result.take();
+  return result.release();
 }
 
 #endif // ELF_SECTION_NOBITS_HXX
--- a/linkloader/include/impl/ELFObject.hxx
+++ b/linkloader/include/impl/ELFObject.hxx
@@ -33,7 +33,7 @@
 template <typename Archiver>
 inline ELFObject<Bitwidth> *
 ELFObject<Bitwidth>::read(Archiver &AR) {
-  llvm::OwningPtr<ELFObjectTy> object(new ELFObjectTy());
+  std::unique_ptr<ELFObjectTy> object(new ELFObjectTy());
 
   // Read header
   object->header.reset(ELFHeaderTy::read(AR));
@@ -54,9 +54,9 @@
       object->stab.push_back(NULL);
       progbits_ndx.push_back(i);
     } else {
-      llvm::OwningPtr<ELFSectionTy> sec(
+      std::unique_ptr<ELFSectionTy> sec(
         ELFSectionTy::read(AR, object.get(), (*object->shtab)[i]));
-      object->stab.push_back(sec.take());
+      object->stab.push_back(sec.release());
     }
   }
 
@@ -69,12 +69,12 @@
   for (size_t i = 0; i < progbits_ndx.size(); ++i) {
     size_t index = progbits_ndx[i];
 
-    llvm::OwningPtr<ELFSectionTy> sec(
+    std::unique_ptr<ELFSectionTy> sec(
       ELFSectionTy::read(AR, object.get(), (*object->shtab)[index]));
-    object->stab[index] = sec.take();
+    object->stab[index] = sec.release();
   }
 
-  return object.take();
+  return object.release();
 }
 
 template <unsigned Bitwidth>
--- a/linkloader/include/impl/ELFReloc.hxx
+++ b/linkloader/include/impl/ELFReloc.hxx
@@ -32,7 +32,7 @@
     return 0;
   }
 
-  llvm::OwningPtr<ELFRelocTy> sh(new ELFRelocTy());
+  std::unique_ptr<ELFRelocTy> sh(new ELFRelocTy());
 
   if (!sh->serializeRela(AR)) {
     // Unable to read the structure.  Return NULL.
@@ -47,7 +47,7 @@
   // Set the section header index
   sh->index = index;
 
-  return sh.take();
+  return sh.release();
 }
 
 template <unsigned Bitwidth>
@@ -60,7 +60,7 @@
     return 0;
   }
 
-  llvm::OwningPtr<ELFRelocTy> sh(new ELFRelocTy());
+  std::unique_ptr<ELFRelocTy> sh(new ELFRelocTy());
 
   sh->r_addend = 0;
   if (!sh->serializeRel(AR)) {
@@ -75,7 +75,7 @@
   // Set the section header index
   sh->index = index;
 
-  return sh.take();
+  return sh.release();
 }
 
 template <unsigned Bitwidth>
--- a/linkloader/include/impl/ELFSectionHeader.hxx
+++ b/linkloader/include/impl/ELFSectionHeader.hxx
@@ -41,7 +41,7 @@
     return 0;
   }
 
-  llvm::OwningPtr<ELFSectionHeaderTy> sh(new ELFSectionHeaderTy());
+  std::unique_ptr<ELFSectionHeaderTy> sh(new ELFSectionHeaderTy());
 
   if (!sh->serialize(AR)) {
     // Unable to read the structure.  Return NULL.
@@ -59,7 +59,7 @@
   // Set the owner elf object
   sh->owner = owner;
 
-  return sh.take();
+  return sh.release();
 }
 
 template <unsigned Bitwidth>
--- a/linkloader/include/impl/ELFSectionHeaderTable.hxx
+++ b/linkloader/include/impl/ELFSectionHeaderTable.hxx
@@ -41,7 +41,7 @@
   }
 
   // Allocate a new section header table and assign the owner.
-  llvm::OwningPtr<ELFSectionHeaderTable> tab(new ELFSectionHeaderTable());
+  std::unique_ptr<ELFSectionHeaderTable> tab(new ELFSectionHeaderTable());
 
   // Get ELF header
   ELFHeaderTy const *header = owner->getHeader();
@@ -53,7 +53,7 @@
   AR.seek(header->getSectionHeaderTableOffset(), true);
 
   for (size_t i = 0; i < header->getSectionHeaderNum(); ++i) {
-    llvm::OwningPtr<ELFSectionHeaderTy> sh(
+    std::unique_ptr<ELFSectionHeaderTy> sh(
       ELFSectionHeaderTy::read(AR, owner, i));
 
     if (!sh) {
@@ -61,10 +61,10 @@
       return 0;
     }
 
-    tab->table.push_back(sh.take());
+    tab->table.push_back(sh.release());
   }
 
-  return tab.take();
+  return tab.release();
 }
 
 template <unsigned Bitwidth>
--- a/linkloader/include/impl/ELFSectionProgBits.hxx
+++ b/linkloader/include/impl/ELFSectionProgBits.hxx
@@ -35,7 +35,7 @@
                                    ELFSectionHeaderTy const *sh) {
   int machine = owner->getHeader()->getMachine();
   ELFSectionProgBits *secp = new ELFSectionProgBits(machine);
-  llvm::OwningPtr<ELFSectionProgBits> result(secp);
+  std::unique_ptr<ELFSectionProgBits> result(secp);
   size_t max_num_stubs = 0;
   // Align section boundary to 4 bytes.
   size_t section_size = (sh->getSize() + 3) / 4 * 4;
@@ -79,7 +79,7 @@
     return NULL;
   }
 
-  return result.take();
+  return result.release();
 }
 
 #endif // ELF_SECTION_PROGBITS_HXX
--- a/linkloader/include/impl/ELFSectionRelTable.hxx
+++ b/linkloader/include/impl/ELFSectionRelTable.hxx
@@ -57,7 +57,7 @@
 
   rsl_assert(sh->getType() == SHT_REL || sh->getType() == SHT_RELA);
 
-  llvm::OwningPtr<ELFSectionRelTable> rt(new ELFSectionRelTable());
+  std::unique_ptr<ELFSectionRelTable> rt(new ELFSectionRelTable());
 
   // Seek to the start of the table
   AR.seek(sh->getOffset(), true);
@@ -84,7 +84,7 @@
     return 0;
   }
 
-  return rt.take();
+  return rt.release();
 }
 
 template <unsigned Bitwidth>
--- a/linkloader/include/impl/ELFSectionSymTab.hxx
+++ b/linkloader/include/impl/ELFSectionSymTab.hxx
@@ -89,7 +89,7 @@
                                  ELFObjectTy *owner,
                                  ELFSectionHeaderTy const *sh) {
 
-  llvm::OwningPtr<ELFSectionSymTabTy> st(new ELFSectionSymTabTy());
+  std::unique_ptr<ELFSectionSymTabTy> st(new ELFSectionSymTabTy());
 
   // Assert that entry size will be the same as standard.
   rsl_assert(sh->getEntrySize() == TypeTraits<ELFSymbolTy>::size);
@@ -108,7 +108,7 @@
     return 0;
   }
 
-  return st.take();
+  return st.release();
 }
 
 template <unsigned Bitwidth>
--- a/linkloader/include/impl/ELFSymbol.hxx
+++ b/linkloader/include/impl/ELFSymbol.hxx
@@ -51,7 +51,7 @@
     return 0;
   }
 
-  llvm::OwningPtr<ELFSymbolTy> sh(new ELFSymbolTy());
+  std::unique_ptr<ELFSymbolTy> sh(new ELFSymbolTy());
 
   if (!sh->serialize(AR)) {
     // Unable to read the structure.  Return NULL.
@@ -69,7 +69,7 @@
   // Set the owner elf object
   sh->owner = owner;
 
-  return sh.take();
+  return sh.release();
 }
 
 template <unsigned Bitwidth>
